"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatHub = void 0;
const ws_1 = require("ws");
const ChatHubRequest_1 = require("./ChatHubRequest"); // Import the ChatHubRequest class (not provided in the code)
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const socks_proxy_agent_1 = require("socks-proxy-agent");
const rxjs_1 = require("rxjs");
class ChatHub {
    constructor(conversation, proxy = null) {
        this.proxy = proxy;
        this.wss = null;
        this.loop = false;
        this.request = new ChatHubRequest_1.ChatHubRequest(conversation.struct.conversationSignature, conversation.struct.clientId, conversation.struct.conversationId);
    }
    askStream(prompt, wssLink, conversationStyle = null) {
        return __asyncGenerator(this, arguments, function* askStream_1() {
            if (this.wss && this.wss.readyState !== ws_1.WebSocket.CLOSED) {
                this.wss.close();
            }
            this.wss = new ws_1.WebSocket(wssLink, {
                headers: constants_1.HEADERS,
                agent: this.proxy ? new socks_proxy_agent_1.SocksProxyAgent(this.proxy) : false,
            });
            const currentWss = this.wss;
            // console.log('a websocket is created');
            // console.log('a websocket is open');
            yield __await(this.initialHandshake());
            this.request.update(prompt, conversationStyle);
            let final = false;
            const responsed = new rxjs_1.Subject();
            currentWss.on('message', (rawData) => {
                var _a;
                if (responsed.closed)
                    return;
                const data = rawData.toString('utf-8');
                const objects = data.split(constants_1.DELIMITER); // Define the DELIMITER constant
                for (const obj of objects) {
                    if (obj === null || obj === '') {
                        continue;
                    }
                    const response = JSON.parse(obj);
                    // console.log(
                    //   chalk.yellowBright('the data for debug: ', JSON.stringify(response)),
                    // );
                    if (response.type === 1 && ((_a = response.arguments[0]) === null || _a === void 0 ? void 0 : _a.messages)) {
                        const respTxt = response.arguments[0].messages[0].adaptiveCards[0].body[0].text;
                        responsed.next([false, respTxt]);
                    }
                    else if (response.type === 2) {
                        // if (response.item.result.error) {
                        //   final = true;
                        //   responsed.error(
                        //     new Error(
                        //       `the response encountered error: [${response.item.result.error}] "${response.item.result.message}"`,
                        //     ),
                        //   );
                        //   responsed.complete();
                        // } else {
                        final = true;
                        responsed.next([true, response]);
                        responsed.complete();
                        // }
                    }
                }
            });
            // console.log(
            //   chalk.bold(
            //     chalk.yellow(
            //       `the sent struct is ${JSON.stringify(this.request.struct)}`,
            //     ),
            //   ),
            // );
            currentWss.send((0, utils_1.appendIdentifier)(this.request.struct)); // Define the appendIdentifier function
            while (!final) {
                const theCurrentValue = yield __await((0, rxjs_1.firstValueFrom)(responsed));
                // console.log(
                //   chalk.bold(
                //     chalk.yellow(
                //       `the current response value is ${JSON.stringify(theCurrentValue)}`,
                //     ),
                //   ),
                // );
                yield yield __await(theCurrentValue);
            }
        });
    }
    initialHandshake() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (this.wss === null) {
                    reject(new Error('WebSocket is not initialized'));
                    return;
                }
                const currentWss = this.wss;
                currentWss.once('message', () => {
                    // console.log(chalk.bold(chalk.yellow('should have resolve here')));
                    resolve();
                });
                currentWss.once('open', () => __awaiter(this, void 0, void 0, function* () {
                    // console.log(chalk.bold(chalk.yellow('should have send here')));
                    currentWss.send((0, utils_1.appendIdentifier)({ protocol: 'json', version: 1 }));
                }));
            });
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wss && this.wss.readyState !== ws_1.WebSocket.CLOSED) {
                this.wss.close();
            }
        });
    }
}
exports.ChatHub = ChatHub;
